# Redefining Everything with the Swift REPL

Our first entry on the REPL covered just the basics, showing how to use the REPL to experiment with Swift as you learn the language. This post explores one way that the REPL bends normal coding rules to give you new powers when developing.

Redefining Identifiers
The Swift compiler automatically protects against a wide range of programming mistakes, including unintentional ambiguity arising from defining the same identifier twice:

```swift
swiftc -
var x = "The Answer"
var x = 42
^D
error: invalid redeclaration of 'x'
```

This makes sense when coding in a non-interactive editor, but in the REPL interactive environment itâ€™s useful to be able to easily make changes. The REPL was specifically designed with this kind of convenience in mind:
```swift
  1> var x = "The Answer"
x: String = "The Answer"
  2> var x = 42
x: Int = 42
  3> x + 10
$R0: Int = 52
```

The newer definition replaces the existing definition for all subsequent references. As illustrated above, even the type of the definition can be changed in the process. This allows a wide range of experiments through iterative refinement. For example, you can start out with a recursive implementation of a function:
```swift
 4> func fib(index: Int) -> Int {
  if index <= 1 
  {
 		return 1
  }

  return fib(index - 1) + fib(index - 2)
}
 
 fib(40)
 
 $R1: Int = 165580141
```
This is just one way to write this function. You can experiment with your code, trying out different algorithms and APIs. The REPL makes it easy to define a new and improved implementation:

```swift
func fib(index: Int) -> Int {
var lastValue = 1
var currentValue = 1
for var iteration = 2; iteration <= index; ++iteration {
let newValue = lastValue + currentValue
lastValue = currentValue
currentValue = newValue
}

return currentValue
}

fib(40)
Int = 165580141
```

Typing the same expression in the REPL now executes the new implementation. This is a simple example, but it illustrates the iterative experimentation that the REPL was designed to facilitate.


## Redefinition or Overload?

Redefining constants, variables, and types all work intuitively, and, as we can see above, it is also possible to redefine functions. This raises an obvious question: how does this interact with function overloading? The REPL only replaces an existing definition when it has the same name and signature as shown in the Fibonacci example above. If a function with the same name but a distinct signature already exists, it just defines a new overload. Keep in mind that Swift allows function overloading even when two signatures differ only in their return type. For example:

